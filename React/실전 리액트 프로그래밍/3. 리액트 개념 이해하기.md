# 3. 리액트 개념 이해하기

## 3.1 상태값과 속성값으로 관리하는 UI 데이터

리액트는 UI 데이터를 관리하는 방법을 제공

UI 데이터는 컴포넌트 내부에서 관리되는 상태값과 부모 컴포넌트에서 내려 주는 속성값으로 구성된다.

리덕스 : 전역 데이터를 관리해주는 라이브러리 => 컴포넌트의 상태값과 속성값 이용해 구현됨

리액트는 화면을 그리는 모든 코드는 컴포넌트의 렌더(render) 함수로 작성하도록 했다.

UI 데이터가 변경되면 리액트가 렌더 함수를 이용해서 화면을 자동으로 갱신



### 3.1.1 리액트를 사용한 코드의 특징

할 일 목록을 추가하거나 삭제할 수 있는 간단한 프로그램

##### 리액트로 작성한 코드

```react
class MyComponent extends React.Component {
    state = { desc: '', currentId: 1, todoList: [] };
	onAdd = () => {
        const { desc, currentId, todoList } = this.state;
        const todo = { id: currentId, desc };
        this.setState({
            currentId: currentId + 1,
            todoList: [...todoList, todo],
        });
    };
	onDelete = e => {
        const { todoList } = this.state;
        const id = Number(e.target.dataset.id);
        const newTodoList = todoList.filter(todo => todo.id !== id);
        this.setState({ todoList: newTodoList });
    };
	onSaveToServer = () => {
        // todoList 전송
    };
	onChangeDesc = e => {
        const desc = e.target.value;
        this.setState({ desc });
    };
	render() {
        const { desc, todoList } = this.state;
        return (
            <div>
                <h3>할 일 목록</h3>
                <ul>
                    {todoList.map(todo => (
                        <li key={todo.id}>
                            <span>{todo.desc}</span>
                            <button data-id={todo.id} onClick={this.onDelete}>
                                삭제
                            </button>
                        </li>
                    ))}
                </ul>
                <input type="text" value={desc} onChange={this.onChangeDesc} />
                <button onClick={this.onAdd}>추가</button>
                <button onClick={this.onSaveToServer}>서버에 저장</button>
            </div>
        );
    }
}
```

render 메서드는 화면에 무엇을 그려야 하는지 설명하는 UI 코드로 이루어져 있다.

상태값을 기반으로 UI를 정의. 상태값이 수정되면 render 메서드를 실행해서 화면을 갱신할 수 있다.



### 3.1.2 컴포넌트의 속성값과 상태값

#### 속성값과 상태값으로 관리하는 UI 데이터

상태값 : 해당 컴포넌트가 관리하는 데이터

속성값 : 부모 컴포넌트로부터 전달받은 데이터

리액트에서 UI 데이터는 반드시 상태값과 속성값으로 관리해야 한다.



##### 컴포넌트의 상태값을 사용하지 않은 코드

```react
class MyComponent extends React.Component {
    color = 'red';
	onClick = () => {
        this.color = 'blue';
    };
	render() {
        return (
            <button style={{ backgroundColor: this.color }} onClick={this.onClick}>
                좋아요
            </button>
        );
    }
}
```

버튼을 누르면 color 변수의 값 수정

color 데이터는 파란색으로 변경되지만, 화면에 보이는 버튼의 배경색은 여전히 빨간색 => 리액트가 UI 데이터가 변경됐다는 사실을 모르기 때문



##### 컴포넌트의 상태값을 사용하는 코드

```react
class MyComponent extends React.Component {
    state = { color: 'red' };
	onClick = () => {
        this.setState({ color: 'blue' });
    };
	render() {
        return (
            <button style={{ backgroundColor: this.state.color }} onClick={this.onClick}>
                좋아요
            </button>
        );
    }
}
```

setState 메서드 => 상태값을 변경하고, 해당 컴포넌트를 다시 렌더링한다.



##### 속성값을 사용한 코드

```react
function Title(props) {
    return <p>{props.title}</p>
}
```

속성값 : 부모 컴포넌트가 전달해 주는 데이터. 대부분의 경우 UI 데이터를 포함

부모 컴포넌트가 렌더링될 때마다 같이 렌더링 된다.



##### 부모 컴포넌트에서 속성값을 내려 주는 코드

```react
class Todo extends React.Component {
    state = { count: 0 };
	onClick = () => {
        const { count } = this.state;
        this.setState({ count: count + 1 });
    };
	render() {
        const { count } = this.state;
        return (
            <div>
                <Title title={`현재 카운트: ${count}`} />
                <button onClick={this.onClick}>증가</button>
            </div>
        );
    }
}
```

버튼을 클릭할 때마다 count 상태값 변경, Todo 컴포넌트의 render 메서드 호출

이 때 Title 컴포넌트는 새로운 title 속성값을 내려받는다.



![image-20200304163525535](images/image-20200304163525535.png)



##### React.memo와 React.pureComponent를 사용한 코드

```react
function Title(props) {
    return <p>{props.title}</p>
}
export default React.memo(Title);

export default class Title extends React.PureComponent {
    render() {
        return <p>{this.props.title}</p>;
    }
}
```

title 속성값이 변경될 때만 렌더링되길 원한다면 React.memo(함수형 컴포넌트) 또는 React.PureComponent(클래스형 컴포넌트)를 이용할 수 있다.



##### 컴포넌트를 사용한 만큼 인스턴스 생성하기

```react
function App() {
    return (
        <div>
            <MyComponent />
            <MyComponent />
        </div>
    );
}
```

같은 컴포넌트 여러번 사용 가능

상태값은 인스턴스마다 별도로 존재



#### setState 메서드

setState : 클래스형 컴포넌트에서 상태값을 변경할 때 호출하는 메서드

##### 상태값을 일부만 변경하는 코드

```react
class MyComponent extends React.Component {
    state = {
        count1: 0,
        count2: 0,
    };
	onClick = () => {
        const { count1 } = this.state;
        this.setState({ count1: count1 + 1 });
    };
	// ...
}
```

setState 메서드로 입력된 객체는 기존 상태값과 병합된다. => count2 상태값은 변경되지 않는다.

setState 메서드가 호출되면 해당 컴포넌트를 다시 그린다. => count1 데이터를 속성값으로 받는 자식 컴포넌트의 렌더 함수도 호출된다.

setState 메서드는 비동기로 상태값을 변경한다.



##### setState 메서드를 연속해서 호출하는 코드

```react
class MyComponent extends React.Component {
    state = {
        count: 0,
    };
	onClick = () => {
        this.setState({ count: this.state.count + 1 });
        this.setState({ count: this.state.count + 1 });
    };
	render() {
        console.log('render called');
        // ...
    }
}
```

count 값이 두 번 증가하는 것을 의도함. 하지만 1만큼 증가한다.

setState 메서드가 비동기로 동작하기 때문. 리액트는 효율적으로 렌더링하기 위해 여러 개의 setState 메서드를 배치(batch)로 처리한다.



##### setState 메서드의 인수로 함수를 사용한 코드

```react
onClick = () => {
    this.setState(prevState => ({ count: prevState.count + 1 }));
    this.setState(prevState => ({ count: prevState.count + 1 }));
};
```

setState 메서드로 입력된 함수는 자신이 호출되기 직전의 상태값을 매개변수로 받는다.

앞의 코드에서 첫 번째 setState 호출이 변경한 상태값이 두 번째 setState 호출의 인수로 사용됨

count 값이 2만큼 증가



##### 상태값 로직을 분리해서 사용하는 패턴

```react
const actions = {
    init() {
        return { count: 0 };
    },
    increment(state) {
        return { count: state.count + 1 };
    },
    decrement(state) {
        return { count: state.count - 1 };
    },
};

class MyComponent extends React.Component {
    state = actions.init();
	onIncrement = () => {
        this.setState(actions.increment);
    };
	onDecrement = () => {
        this.setState(actions.decrement);
    };
	// ...
}
```

컴포넌트에서 setState 메서드를 호출할 때는 필요한 함수를 인수로 넣는다.



##### 호출 순서가 보장되는 setState 메서드

```react
class MyComponent extends React.Component {
    state = {
        count1: 0,
        count2: 0,
    };
	onClick = () => {
        const { count1, count2 } = this.state;
        this.setState({ count1: count1 + 1 });
        // ...
        this.setState({ count2: count2 + 1 });
    };
	render() {
        const { count1, count2 } = this.state;
        const result = count1 >= count2;
        // ...
    }
}
```

setState 메서드는 비동기로 처리되지만 그 순서가 보장된다.

result 변수는 항상 참



##### setState 메서드의 두 번째 매개변수는 처리가 끝났을 때 호출된다

```react
onClick = () => {
    this.setState({ count: 123 }, () => console.log('count is 123'));
};
```

콜백 함수는 상태값 변경 후에 호출되기 때문에 변경된 상태값을 기반으로 다음 작업을 처리할 때 유용하게 사용됨



#### 불변 객체로 관리하는 속성값과 상태값

속성값은 불변 객체이지만 상태값은 불변 객체가 아니다. 하지만 불변 객체로 관리하는 게 좋다.



##### 속성값 변경을 시도하는 코드

```react
function Title(props) {
    props.title = 'abc';
    // ...
}
```

속성값은 불변 객체이기 때문에 값을 변경하려고 시도하면 에러가 발생



##### 상태값을 직접 수정하는 코드

```react
onClick = () => {
    this.state.comment = 'Hello';
    this.forceUpdate();
};
```

직접 수정 후 forceUpdate 메서드를 호출하면 새로운 값과 함께 화면을 다시 그린다.

하지만 상태값도 불변 객체로 관리하는 게 좋다. => 렌더링 성능이 좋아진다.



## 3.2 리액트 요소와 가상 돔

리액트 요소(element)는 리액트가 UI를 표현하는 수단이다.

리액트는 성능을 위해 가상 돔을 활용한다.

메모리에 가상 돔을 올려 놓고 이전과 이후의 가상 돔을 비교해서 변경된 부분만 실제 돔에 반영



### 3.2.1 리액트 요소 이해하기

JSX 문법으로 작성된 코드 => createElement 함수로 변경

createElement 함수는 리액트 요소를 반환한다.

##### JSX 코드가 createElement 함수를 사용하는 코드로 변경된 예

```react
const element = <a href="http://google.com">click here</a>;
const element = React.createElement(
    'a',
    { href: 'http://google.com' },
    'click here',
);
```



##### 리액트 요소의 구조

```react
const element = (
    <a key="key1" style={{ width: 100 }} href="http://google.com">
        click here
    </a>
);
console.log(element);
const consoleLogResult = {
    type: 'a',
    key: 'key1',
    ref: null,
    props: {
        href: 'http://google.com',
        style: {
            width: 100,
        },
        children: 'click here',
    },
    // ...
};
```

element 변수는 createElement 함수가 반환한 리액트 요소이다.

consoleLogResult 변수는 리액트 요소를 로그로 출력한 결과를 표현한 것이다.

* type 속성
  * 문자열이면 HTML 태그, 함수면 컴포넌트
* key, ref 속성
* key와 ref를 제외한 나머지 속성값은 props 속성값으로 들어간다.



##### JSX 코드에서 태그 사이에 표현식을 넣은 코드

```react
const element = <h1>제 나이는 {20 + 5} 세입니다</h1>;
console.log(element);
const consoleLogResult = {
    type: 'h1',
    props: { children: ['제 나이는 ', 25, ' 세입니다'] },
    // ...
};
```

JSX 코드에서 태그 사이에 표현식이 들어가면, 리액트 요소에는 이 표현식이 여러 개로 분할되어 들어간다.

JSX 코드에서 컴포넌트가 사용되면, 리액트 요소의 type 속성값은 해당 컴포넌트의 함수가 된다.



##### 컴포넌트가 리액트 요소로 변경된 예

```react
function Title({ title, color }) {
    return <p style={{ color }}>{title}</p>;
}
const element = <Title title="안녕하세요" color="blue" />;
console.log(element);
const consoleLogResult = {
    type: Title,
    props: { title: '안녕하세요', color: 'blue' },
    // ...
};
```



##### 리액트 요소는 불변 객체이다

```react
const element = <a href="http://google.com">click here</a>;
element.type = 'b';  // 에러 발생
```

속성값을 변경할 수 없다.



##### ReactDOM.render 함수를 주기적으로 호출하는 코드

```react
let seconds = 0;
function update() {
    seconds += 1;
    const element = (
        <div>
            <h1>안녕하세요</h1>
            <h2>지금까지 {seconds}초가 지났습니다.</h2>
        </div>
    );
    ReactDOM.render(element, document.getElementById('root'));
}

setInterval(update, 1000);
```

리액트는 전달된 리액트 요소를 이전의 리액트 요소와 비교해서 변경된 부분만 실제 돔에 반영한다.

1초마다 update 함수를 호출해서 화면을 갱신한다.

리액트 요소에서 변경되는 유일한 부분은 seconds 변수로 표현된 숫자 부분이다.



### 3.2.2 리액트 요소가 돔 요소로 만들어지는 과정

* 하나의 화면을 표현하기 위해 여러 개의 리액트 요소가 트리(tree) 구조로 구성된다.
* 하나의 리액트 요소 트리는 시간에 따라 변화하는 화면의 한순간을 나타낸다.
* 리액트에서 데이터 변경에 의한 화면 업데이트는 렌더 단계와 커밋 단계를 거친다.
  * 렌더 단계 : 실제 돔에 반영할 변경 사항을 파악하는 단계. 가상 돔 이용
  * 커밋 단계 : 파악된 변경 사항을 실제 돔에 반영하는 단계
* 가상 돔은 리액트 요소로부터 만들어진다.



##### 할 일의 우선순의를 상태값으로 관리하는 코드

```react
class Todo extends React.Component {
    state = {
        priority: 'high',
    };
	onClick = () => {
        const { priority } = this.state;
        this.setState({ priority: priority === 'high' ? 'low' : 'high' });
    };
	render() {
        const { title, desc } = this.props;
        const { priority } = this.state;
        return (
            <div>
                <Title title={title} />
                <p>{desc}</p>
                <p>{priority === 'high' ? '우선순위 높음' : '우선순위 낮음'}</p>
                <button onClick={this.onClick}>우선순위 변경</button>
            </div>
        );
    }
}

class Title extends React.PureComponent {
    render() {
        const { title } = this.props;
        return <p style={{ color: 'blue' }}>{title}</p>
    }
}

ReactDOM.render(
    <Todo title="리액트 공부하기" desc="실전 리액트를 열심히 읽는다" />,
    document.getElementById('root'),
);
```

Todo 컴포넌트는 Title 컴포넌트를 자식으로 사용한다.

버튼을 클릭하면 priority 상태값이 변경되고 화면을 다시 그린다.

PureComponent로 만들어진 Title 컴포넌트는 상태값이나 속성값이 변경될 때만 render 메서드를 호출한다.



##### 첫 번째로 만들어지는 리액트 요소

```react
const initialElementTree = {
    type: Todo,
    props: {
        title: '리액트 공부하기',
        desc: '실전 리액트를 열심히 읽는다',
    },
    // ...
};
```

ReactDOM.render 함수로 전달된 리액트 요소 트리의 구조



##### Todo 컴포넌트의 렌더 함수 호출 결과

```react
const elementTree = {
    type: 'div',
    props: {
        children: [
            {
                type: Title,
                props: { title: '리액트 공부하기' },
                // ,,,
            },
            {
                type: 'p',
                props: { children: '실전 리액트를 열심히 읽는다' },
                // ...
            },
            {
                type: 'button',
                props: {
                    onClick: function() {
                        /* Todo 컴포넌트의 onClick 함수 */
                    },
                    children: '우선순위 변경',
                },
                // ...
            },
        ],
    },
    // ...
};
```

트리의 루트는 div 태그로 변경된다.

아직 Title 컴포넌트가 존재하기 때문에 이 트리를 실제 돔으로 만들 수는 없다.

리액트 요소 트리가 실제 돔으로 만들어지기 위해서는 모든 리액트 요소의 type 속성값이 문자열이어야 한다.



##### Title 컴포넌트의 렌더 함수 호출 결과

```react
const elementTree = {
    type: 'div',
    props: {
        children: [
            {
                type: 'p',
                props: {
                    style: { color: 'blue' },
                    children: '리액트 공부하기',
                },
                // ...
            },
            {
                type: 'p',
                props: { children: '실전 리액트를 열심히 읽는다' },
                // ...
            },
            {
                type: 'p',
                props: { children: '우선순위 높음' },
                // ...
            },
            {
                type: 'button',
                props: {
                    onClick: function() {
                        /* Todo 컴포넌트의 onClick 함수 */
                    },
                    children: '우선순위 변경',
                },
                // ...
            },
        ],
    },
    // ...
};
```

Title 컴포넌트로 표현됐던 리액트 요소가 p 태그로 변경됨

모든 리액트 요소의 type 속성값이 문자열 => 실제 돔을 만들 수 있다.

실제 돔을 만들 수 있는 리액트 요소 트리를 가상 돔이라고 한다.



렌더 단계 : 최초의 리액트 요소 트리로부터 가상 돔을 만들고 이전 가상 돔과 비교해서 실제 돔에 반영할 내용을 결정하는 단계

렌더 단계는 ReactDOM.render 함수와 setState 메서드에 의해 시작된다.



##### setState 메서드 호출 후 만들어진 리액트 요소 트리

```react
const elementTree = {
    type: 'div',
    props: {
        children: [
            {
                type: Title,
                props: { title: '리액트 공부하기' },
                // ...
            },
            {
                type: 'p',
                props: { children: '실전 리액트를 열심히 읽는다' },
                // ...
            },
            {
                type: 'p',
                props: { children: '우선순위 낮음' },
                // ...
            },
        // 아래 코드는 같음
```

Title 컴포넌트는 PureComponent로 만들어졌고, 속성값이 변하지 않았기 때문에 이전 결과가 재사용된다.



## 3.3 생명 주기 메서드

모든 컴포넌트는 다음과 같이 세 단계를 거친다.

* 초기화 단계
* 업데이트 단계
* 소멸 단계

각 단계 속에서 호출되는 메서드를 생명 주기 메서드라고 한다.



#### 초기화 단계

최초게 컴포넌트 객체가 생성될 때 한 번 수행된다.

* constructor()
* static getDerivedStateFromProps()
* render()
* componentDidMount()



#### 업데이트 단계

초기화 단계와 소멸 단계 사이에서 반복해서 수행된다.

컴포넌트의 속성값이나 상태값이 변경되면 수행된다.

* static getDerivedStateFromProps()
* shouldComponentUpdate()
* render()
* getSnapshotBeforeUpdate()
* componentDidUpdate()



#### 소멸 단계

* componentWillUnmount()



#### 렌더링 시 예외가 발생하면 호출되는 메서드

* static getDerivedStateFromError()
* componentDidCatch()



http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram



### 3.3.1 constructor 메서드

```react
constructor(props)
```

props 매개변수는 컴포넌트의 기본 속성값이 적용된 상태로 호출된다.

contructor 메서드 내부에서 반드시 super 함수를 호출해야 한다.



##### contructor 메서드의 기본 구조

```react
class MyComponent extends React.Component {
    constructor(props) {
        super(props);
        // ...
    }
}
```

super 함수를 호출해야 React.Component 클래스의 constructor 메서드가 호출된다.



##### 초기 속성값으로부터 상태값을 만드는 코드

```react
class MyComponent extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            currentMovie: props.age < 10 ? '뽀로로' : '어벤져스',
        };
    }
}
```

상태값을 직접 할당하는 것은 constructor 메서드에서만 허용

초기 속성값을 이용해서 상태값을 정의하기 위해 constructor 메서드를 작성하는 경우가 많다.



##### constructor 메서드 없이 속성값을 이용하는 코드

```react
class MyComponent extends React.Component {
    state = {
        currentMovie: this.props.age < 10 ? '뽀로로' : '어벤져스',
    };
}
```

클래스 필드 사용 같은 기능 구현



##### 속성값에 항상 의존적인 상태값을 함수로 대체한 코드

```react
class MyComponent extends React.Component {
    getCurrentMovie() {
        const { age } = this.props;
        return age < 10 ? '뽀로로' : '어벤져스';
    }
}
```



#### constructor 메서드에서는 setState 메서드를 호출하지 말자

setState 메서드 호출은 컴포넌트가 마운트된 이후에만 유효하기 때문에 constructor 메서드 내부에서 호출되는 setState 메서드는 무시된다.



##### constructor 메서드에서 setState 메서드를 호출하는 잘못된 예

```react
class MyComponent extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            count: 0,
        };
        this.setState({ count: 10 });
    }
    render() {
        const { count } = this.state;
        return <div>{count}</div>;
    }
}
```

render 메서드에서는 초기값 0이 출력된다.



##### constructor 메서드에서 API를 호출하는 잘못된 예

```react
class MyComponent extends React.Component {
    state = {
        products: [],
    };
	constructor(props) {
        super(props);
        callApi('/products').then(data => {
            // ...
            this.setState({ products: data });
        });
    }
}
```

constructor 메서드에서 비동기로 받아온 데이터를 setState 메서드를 이용해서 상태값으로 저장

setState 호출은 무시된다.

데이터를 가져오기 위해 호출하는 API는 componentDidMount 메서드 내부에서 호출하는 게 적절하다.



### 3.3.2 getDerivedStateFromProps 메서드

속성값을 이용해서 새로운 상태값을 만들 때 사용

render 메서드가 호출되기 직전에 호출된다.



```react
static getDerivedStateFromProps(props, state)
```

정적 메서드이기 때문에 함수 내부에서 this 객체에 접근할 수 없다.

속성값과 상태값을 기반으로 새로운 상태값을 만든다.

시간에 따라 변하는 속성값으로부터 상태값을 계산하기 위해 추가됐다.

에니메이션과 관련된 속성값으로부터 상태값을 계산할 때 유용

이전 속성값 저장



##### getDerivedStateFromProps 메서드에서 이전 속성값 이용하기

```react
class MyComponent extends React.Component {
    state = {
        // ...
        prevSpeed: this.props.speed,
    };
	static getDerivedStateFromProps(props, state) {
        if (props.speed !== state.prevSpeed) {
            // ...
            return {
                // ...
                prevSpeed: props.speed,
            };
        }
        return null;
    }
}
```

prevSpeed 상태값은 이전 speed 속성값을 저장하기 위한 용도

속성값이 변경된 경우에 필요한 처리를 하고, 변경된 속성값을 상태값으로 저장한다.

상태값을 변경할 필요가 없다면 null을 반환한다.



* getDerivedStateFromProps 메서드를 잘못 사용하는 경우
  * 속성값 변화에 따라 API를 호출해야 하는 경우
  * 속성값을 입력으로 하는 메모이제이션을 상태값으로 관리하는 경우
  * 속성값이 변경될 때 상태값을 초기화하는 경우



#### 속성값 변화에 따른 API 호출

getDerivedStateFromProps 메서드는 정적 메서드이기 때문에 this 객체에 접근할 수 없다.

componentDidUpdate 메서드에서 처리



##### componentDidUpdate 메서드에서 API를 호출하는 코드

```react
class MyComponent extends React.Component {
    componentDidUpdate(prevProps) {
        const { productId } = this.props;
        if (prevProps.productId !== productId) {
            this.requestData(productId);
        }
    }
}
```

requestData를 호출하려면 this 객체가 필요하므로 getDerivedStateFromProps 메서드에서는 호출할 수 없다.



#### 속성값을 입력으로 하는 메모이제이션

메모이제이션 : 불필요한 계산량을 줄이기 위한 기술. 같은 입력값에 대해 항상 같은 출력값이 나온다면 메모이제이션 이용 가능



##### getDerivedStateFromProps 메서드를 이용한 메모이제이션

```react
class MyComponent extends React.Component {
    static getDerivedStateFromProps(props, state) {
        const { products } = props;
        if (products !== state.prevProducts) {
            return {
                filteredProducts: products.filter(product => product.price < 1000),
                prevProducts: products,
            };
        }
        return null;
    }
    render() {
        const { filteredProducts } = this.state;
        return <div>{filteredProducts.map(/* ... */)}</div>;
    }
}
```

상품 리스트가 변경된 경우 filteredProducts 값을 새로 계산한다.

getDerivedStateFromProps 메서드를 이용한 메모이제이션은 최소 두 개의 상태값이 필요하다.

render 메서드에서 직접 메모이제이션을 이용하는 것이 좋다.



##### 로다시 패키지를 이용한 메모이제이션의 예

```react
import memoize from 'lodash/memoize';

class MyComponent extends React.Component {
    getFilteredProducts = memoize(function(products) {
        return products.filter(product => product.price < 1000);
    });
	render() {
        const { products } = this.props;
        const filteredProducts = this.getFilteredProducts(products);
        return <div>{filteredProducts.map(/* ... */)}</div>;
    }
}
```

메모이제이션을 위해 로다시 패키지의 memoize 함수 이용

getFilteredProducts 메서드는 products 매개변수가 변경되는 경우에만 계산하고, 변경되지 않으면 이전의 결과를 반환한다.

render 메서드가 호출될 때마다 getFilteredProducts 메서드를 호출한다.



#### 속성값 변경 시 상태값 초기화

##### 속성값 변경 시 상태값을 초기화하는 코드

```react
class PriceInput extends React.Component {
    static getDerivedStateFromProps(props, state) {
        if (props.price !== state.prevPrice) {
            return {
                price: props.price,
                prevPrice: props.price,
            };
        }
        return null;
    }
    onChange = event => {
        const price = Number(event.target.value);
        if (!Number.isNaN(price)) {
            this.setState({ price });
        }
    };
	render() {
        const { price } = this.state;
        return <input onChange={this.onChange} value={price} />;
    }
}
```

price 속성값이 변경되면 price 상태값을 새로운 값으로 초기화

price 상태값은 사용자 입력에 의해 변경될 수 있다.

상품이 변경되면 PriceInput 컴포넌트의 price 상태값도 초기화되어야 한다. 하지만 앞의 코드는 두 상품의 가격이 같다면 price 상태값은 초기화되지 않는다.



##### key 속성값을 이용한 코드

```react
class ProductEdit extends React.Component {
    // ...
    render() {
        const { product } = this.props;
        return <PriceInput key={product.id} price={product.price} />;
    }
}

class PriceInput extends React.Component {
    state = {
        price: this.props.price,
    };
	onChange = event => {
        const price = Number(event.target.value);
        if (!Number.isNaN(price)) {
            this.setState({ price });
        }
    };
	render() {
        const { price } = this.state;
        return <input onChange={this.onChange} value={price} />;
    }
}
```

첫 번째 해결 방법 : PriceInput 컴포넌트에 key 속성값을 부여

컴포넌트에 key 속성값을 부여하고 key 값을 변경하면 이전의 컴포넌트 인스턴스는 사라지고 새로운 인스턴스가 생성된다.

PriceInput 컴포넌트에서는 초기 가격만 상태값에 넣으면 되므로, getDerivedStateFromProps 메서드는 필요 없게 된다.



##### 상태값을 부모 컴포넌트에서 관리하는 코드

```react
class ProductEdit extends React.Component {
    state = {
        currentPrice: this.props.product.price,
    };
	onChangePrice = event => {
        const currentPrice = Number(event.target.value);
        if (!Number.isNaN(currentPrice)) {
            this.setState({ currentPrice });
        }
    };
	render() {
        const { currentPrice } = this.state;
        return <PriceInput onChange={this.onChangePrice} price={currentPrice} />;
    }
}

function PriceInput({ price, onChange }) {
    return <input onChange={onChange} value={price} />;
}
```

두 번째 해결 방법 : 부모 컴포넌트에서 관리

이전에 PriceInput 컴포넌트가 갖고 있던 상태값을 부모 컴포넌트가 관리한다.

상태값을 변경하는 이벤트 처리 메서드도 부모 컴포넌트에서 정의



#### getDerivedStateFromProps 메서드가 필요한 경우

이전 속성값과 이후 속성값 모두에 의존적인 상태값이 필요한 경우

##### 상태값이 전후 속성값에 의존적인 경우

```react
class MyComponent extends React.Component {
    state = {
        // ...
        prevSpeed: this.props.speed,
        isMovingFaster: false,
    };
	static getDerivedStateFromProps(props, state) {
        if (props.speed !== state.prevSpeed) {
            return {
                isMovingFaster: state.prevSpeed < props.speed,
                prevSpeed: props.speed,
            };
        }
        return null;
    }
}
```

isMovingFaster 상태값은 이전 속성값과 이후 속성값으로 계산된다.



### 3.3.3 render 메서드

render 메서드는 컴포넌트를 정의할 때 반드시 작성해야 한다.



##### render 메서드가 반환할 수 있는 값

```react
return <MyComponent title="안녕하세요" />;
return <p>안녕하세요</p>;
return '안녕하세요';
return 123;
return [<p key="a">안녕하세요</p>, <p key="b">반갑습니다</p>];
return (
    <React.Fragment>
        <p>안녕하세요</p>
        <p>반갑습니다</p>
    </React.Fragment>
);
return null;
return false;
return ReactDOM.createPortal(<p>안녕하세요</p>, domNode);
```

작성한 컴포넌트, HTML에 정의된 거의 모든 태그 사용 가능

문자열, 숫자 반환 가능

배열 반환 가능 (각 리액트 요소는 key 속성값을 갖고 있어야 한다.)

리액트 프래그먼트를 사용하면 내부의 리액트 요소에 key 속성값을 부여하지 않아도 된다.

null 또는 bool을 반환하면 아무것도 렌더링하지 않는다.

리액트 포털(portal)을 사용하면 컴포넌트의 현재 위치와는 상관없이 특정 돔 요소에 렌더링할 수 있다.



##### 렌더 함수에서 조건부 렌더링을 하는 코드

```react
function MyComponent({ title }) {
    return title.length > 0 && <p>{title}</p>;
}
```

title 속성값의 길이가 0이면 거짓을 반환 => 아무것도 렌더링되지 않는다.



##### 리엑트 포털을 사용한 코드

```react
function Modal({ title, desc }) {
    const domNode = document.getElementById('modal');
    return ReactDOM.createPortal(
        <div>
            <p>{title}</p>
            <p>{desc}</p>
        </div>,
        domNode,
    );
}
```

리액트 포털을 이용해서 특정 돔 위치에 리액트 요소를 렌더링할 수 있다.

Modal 컴포넌트가 사용된 위치와 상관없이 렌더링할 위치를 선택할 수 있다.



* 렌더 함수는 순수 함수로 작성해야 한다.
  * 렌더 함수 내부에서 setState를 호출하면 안 된다.
  * 렌더 함수의 반환값은 속성값과 상태값만으로 결정되어야 한다.
  * 부수 효과를 발생시키면 안 된다. (서버와 통신하기, 브라우저의 쿠키에 저장하기 등)
    * 필요하다면 다른 생명 주기 메서드에서 수행



### 3.3.4 componentDidMount 메서드

render 메서드의 첫 번째 반환값이 실제 돔에 반영된 직후 호출된다.

render 메서드에서 반환한 리액트 요소가 돔에 반영되어야 알 수 있는 값을 얻을 수 있다.



##### componentDidMount 메서드에서 돔 요소에 접근하는 코드

```react
class Box extends React.Component {
    state = {
        boxWidth: 0,
    };
	divRef = React.createRef();
	componentDidMount() {
        const rect = this.divRef.current.getBoundingClientRect();
        this.setState({ boxWidth: rect.width });
    }
	render() {
        const { boxWidth } = this.state;
        const backgroundColor = boxWidth < 400 ? 'red' : 'blue';
        return (
            <div
                ref={this.divRef}
                style={{ width: '100%', height: '100px', backgroundColor }}
            >
                box
            </div>
        );
    }
}
```

돔 요소에 접근하기 위해 createRef 함수 사용

createRef 함수는 리액트 요소와 연결된 돔 요소에 접근할 때 사용

componentDidMount 메서드가 호출될 때는 리액트 요소가 돔 요소로 만들어진 시점 => 돔 요소로부터 필요한 정보를 가져올 수 있다.

componentDidMount 메서드는 API 호출을 통해 데이터를 가져올 때 적합하다.



##### constructor 메서드에서 API 요청을 보내는 코드

```react
class MyComponent extends React.Component {
    constructor(props) {
        super(props);
        this.dataPromise = requestData();
    }
    componentDidMount() {
        this.dataPromise.then(data => this.setState({ data }));
    }
}
```

constructor 메서드에서 API 호출을 하고 componentDidMount 메서드에서 setState 메서드 호출 => 프로미스 이용

requestData 함수는 API 호출을 하고 프로미스 객체를 반환

componentDidMount 메서드에서 API 응답값을 컴포넌트 상태값으로 저장



### 3.3.5 shouldComponentUpdate 메서드

성능 최적화를 위해 존재

```react
shouldComponentUpdate(nextProps, nextState)
```

불 타입을 반환한다.

참을 반환하면 render 함수가 호출된다. 거짓을 반환하면 업데이트 단계는 여기서 멈춘다.



##### shouldComponentUpdate 메서드의 기본 구조

```react
class MyComponent extends React.Component {
    shouldComponentUpdate(nextProps, nextState) {
        const { price } = this.state;
        return price !== nextState.price;
    }
}
```

price 상태값이 변경된 경우에만 참을 반환 => 속성값과 나머지 상태값이 변경돼도 렌더링되지 않는다.

이 메서드를 별도로 구현하지 않으면 항상 참을 반환하는 함수가 사용된다.

렌더링 성능 최적화에 사용



### 3.3.6 getSnapshotBeforeUpdate 메서드

렌더링 결과가 실제 돔에 반영되기 직전에 호출

이전 돔 요소의 상태값을 가져오기 좋다.



* 업데이트 단계에서 실행되는 생명 주기 메서드의 호출 순서
  * static getDerivedStateFromProps()
  * shouldComponentUpdate()
  * render()
  * getSnapshotBeforeUpdate()
  * componentDidUpdate()



getSnapshotBeforeUpdate와 componentDidUpdate 사이에서 가상 돔이 실제 돔에 반영된다.



```react
getSnapshotBeforeUpdate(prevProps, prevState) => snapshot
```



getSnapshotBeforeUpdate 가 반환한 값은 componentDidUpdate 메서드의 세 번째 인자로 들어간다.

getSnapshotBeforeUpdate 에서 이전 돔의 상태값을 반환하면, componentDidUpdate 에서는 돔의 이전 상태값과 이후 상태값을 모두 알기 때문에 돔의 상태값 변화를 알 수 있다.



##### 돔 요소의 높이값이 변경됐는지 검사하는 코드

```react
class MyComponent extends React.Component {
    state = {
        items: [],
    };
	divRef = React.createRef();
	getSnapshotBeforeUpdate(prevProps, prevState) {
        const { items } = this.state;
        if (prevState.items.length < items.length) {
            const rect = this.divRef.current.getBoundingClientRect();
            return rect.height;
        }
        return null;
    }
	componentDidUpdate(prevProps, prevState, snapshot) {
        if (snapshot !== null) {
            const rect = this.divRef.current.getBoundingClientRect();
            if (rect.height !== snapshot) {
                alert('새로운 줄이 추가되었습니다.');
            }
        }
    }
	onClick = () => {
        const { items } = this.state;
        this.setState({ items: [...items, '아이템'] });
    };
	render() {
        const { items } = this.state;
        return (
            <React.Fragment>
                <button onClick={this.onClick}>추가하기</button>
                <div ref={this.divRef} style={{ width: '100%' }}>
                    {items.map(item => <span style={{ height: 50 }}>{item}</span>)}
                </div>
            </React.Fragment>
        );
    }
}
```

데이터 추가 시 div 돔 요소의 높이값이 변경됐는지 검사하는 코드

div 요소의 높이값이 변경될 때마다 알림창이 뜬다.



### 3.3.7 componentDidUpdate 메서드

업데이트 단계에서 마지막으로 호출되는 생명 주기 메서드

```react
componentDidUpdate(prevProps, prevState, snapshot)
```



가상 돔이 실제 돔에 반영된 후 호출된다.

새로 반영된 돔의 상태값을 가장 빠르게 가져올 수 있다.



##### 스크롤이 가능해지면 알려 주는 코드

```react
class MyComponent extends React.Component {
    state = {
        text: '',
    };
	divRef = React.createRef();
	componentDidUpdate() {
        const div = this.divRef.current;
        const rect = div.getBoundingClientRect();
        if (div.scrollWidth > rect.width) {
            alert('스크롤이 가능합니다.');
        }
    }
	onChange = event => {
        const text = event.target.value;
        this.setState({ text });
    };
	render() {
        const { text } = this.state;
        return (
        	<React.Fragment>
            	<input onChange={this.onChange} value={text} />
                <div
                    ref={this.divRef}
                    style={{ width: 100, height: 100, overflow: 'scroll' }}
                >
                	{text}
                </div>
            </React.Fragment>
        );
    }
}
```

div 요소의 가로 길이보다 스크롤 영역의 가로 길이가 더 크면 스크롤이 가능하다고 알려준다.



##### componentDidUpdate 메서드에서 API를 호출하는 코드

속성값이나 상태값이 변경된 경우 API를 호출하는 용도로 사용되기도 한다.

```react
class UserInfo extends React.Component {
    componentDidUpdate(prevProps) {
        const { user } = this.props;
        if (prevProps.user.id !== user.id) {
            requestFriends(user).then(friends => this.setState({ friends }));
        }
    }
}
```

사용자가 변경되면 친구 목록을 가져오는 API 호출



##### componentDidMount 메서드에서도 API를 호출하도록 변경하기

```react
class UserInfo extends React.Component {
    componentDidMount() {
        const { user } = this.props;
        this.setFriends(user);
    }
    componentDidUpdate(prevProps) {
        const { user } = this.props;
        if (prevProps.user.id !== user.id) {
            this.setFriends(user);
        }
    }
    setFriends(user) {
        requestFriends(user).then(friends => this.setState({ friends }));
    }
}
```

componentDidUpdate 는 초기화 단계에서는 호출되지 않는다. 따라서 친구 목록을 가져오는 API는 componentDidMount 에서도 호출할 필요가 있다.

코드 중복 => 리액트 훅으로 해결 가능



### 3.3.8 componentWillUnmount 메서드

소멸 단계에서 호출되는 유일한 생명 주기 메서드

끝나지 않은 네트워크 요청 취소, 타이머 해제, 구독 해제 등의 작업 처리

컴포넌트에서 componentDidMount 가 호출되면 componentWillUnmount 도 호출되는 것이 보장된다.



##### componentWillUnmount 메서드에서 이벤트 처리 메서드 해제하기

```react
class MyComponent extends React.Component {
    componentDidMount() {
        const domNode = document.getElementById('someNode');
        domNode.addEventListener('change', this.onChange);
        domNode.addEventListener('dragstart', this.onDragStart);
    }
    componentWillUnmount() {
        const domNode = document.getElementById('someNode');
        domNode.removeEventListener('change', this.onChange);
        domNode.removeEventListener('dragstart', this.onDragStart);
    }
}
```

특정 돔 요소에 addEventListener 함수를 이용해 이벤트 처리 함수를 등록하고, removeEventListener 함수를 이용해 등록 해제 가능



### 3.3.9 getDerivedStateFromError, componentDidCatch 메서드

생명 주기 메서드에서 발생한 예외를 처리할 수 있다.

생명 주기 메서드에서 예외가 발생하면 getDerivedStateFromError 또는 componentDidCatch 메서드를 구현한 가장 가까운 부모 컴포넌트를 찾는다.

```react
static getDerivedStateFromError(error)
componentDidCatch(error, info)
```

error 매개변수 : 예외가 발생할 때 전달된 에러 객체

info 매개변수 : 어떤 컴포넌트에서 예외가 발생했는지 알려 준다.



getDerivedStateFromError 정적 메서드는 에러 정보를 상태값에 저장해서 화면에 나타내는 용도로 사용

componentDidCatch 메서드는 에러 정보를 서버로 전송하는 용도로 사용



##### ErrorBoundary 컴포넌트

```react
class ErrorBoundary extends React.Component {
    state = { error: null };
	static getDerivedStateFromError(error) {
        return { error };
    }
	componentDidCatch(error, info) {
        sendErrorToServer(error, info);
    }
	render() {
        const { error } = this.state;
        if (error) {
            return <div>{error.toString()}</div>;
        }
        return this.props.children;
    }
}
```

자식 컴포넌트에서 발생한 예외를 처리하는 부모 컴포넌트의 코드

자식 컴포넌트에서 예외가 발생하면 상태값에 에러 정보를 저장

render 에서는 에러가 존재하면 에러 정보를 렌더링하고, 에러가 없다면 자식 컴포넌트를 렌더링한다.

ErrorBoundary 컴포넌트를 애플리케이션의 최상위 컴포넌트로 만들면 생명 주기 메서드에서 발생하는 모든 예외를 처리할 수 있다.



##### ErrorBoundary 컴포넌트를 사용한 코드

```react
class Counter extends React.Component {
    state = { count: 0 };
	onClick = () => {
        const { count } = this.state;
        this.setState({ count: count + 1 });
    };
	render() {
        const { count } = this.state;
        if (count >= 3) {
            throw new Error('에러 발생!!!');
        }
        return <div onClick={this.onClick}>{`클릭하세요(${count})`}</div>;
    }
}

function App() {
    return (
    	<ErrorBoundary>
        	<Counter />
        </ErrorBoundary>
    );
}
```

ErrorBoundary 컴포넌트를 애플리케이션의 최상위 컴포넌트로 만들었다.

자식 컴포넌트인 Counter 컴포넌트에서 발생하는 예외를 처리할 수 있다.



ErrorBoundary 컴포넌트를 여러 곳에서 사용해도 괜찮다. 그러면 예외가 발생한 일부 화면에만 에러 정보가 렌더링되고, 나머지 부분은 정상적으로 렌더링된다.



##### 이벤트 처리 메서드에서 예외가 발생하는 경우

```react
onClick = () => {
    this.setState({ name: 'mike' });
    throw new Error('some error');
    this.setState({ age: 23 });
};
```

이벤트 처리 메서드에서 발생하는 예외는 ErrorBoundary 컴포넌트로 처리되지 않는다.

예외가 발생한 코드 밑에 있는 setState 메서드는 호출되지 않는다. => 일부 상태값만 변경되기 때문에 잘못된 정보가 사용자에게 노출될 수 있다.



##### 이벤트 처리 메서드에서 예외 처리하는 코드

```react
onClick = () => {
    try {
        this.setState({ name: 'mike' });
        throw new Error('some error');
        this.setState({ age: 23 });
    } catch (e) {
        // ...
    }
};
```

이벤트 처리 메서드에서는 try catch 문을 이용해서 예외 처리를 해야한다.



## 3.4 콘텍스트 API로 데이터 전달하기

콘텍스트 API를 사용하면 컴포넌트의 중첩 구조가 복잡한 상황에서도 비교적 쉽게 데이터를 전달할 수 있다.

콘텍스트 API를 사용하면 상위 컴포넌트에서 하위에 있는 모든 컴포넌트로 직접 데이터를 전달할 수 있다.

중간에 있는 컴포넌트는 콘텍스트 데이터의 존재를 몰라도 되므로 속성값을 반복해서 내려 주던 문제가 사라진다.



##### 콘텍스트 API를 사용하지 않은 코드

```react
class App extends React.Component {
    render() {
        return (
        	<div>
            	<div>상단 메뉴</div>
                <Profile username="mike" />
                <div>하단 메뉴</div>
            </div>
        );
    }
}

function Profile({ username }) {
    return (
    	<div>
        	<Greeting username={username} />
            {/* ... */}
        </div>
    );
}

function Greeting({ username }) {
    return <p>{`${username}님 안녕하세요`}</p>;
}
```

App 컴포넌트에서 Greeting 컴포넌트로 속성값을 전달

Profile 컴포넌트는 username 속성값을 사용하지 않고 기계적으로 전달



### 3.4.1 콘텍스트 API 이해하기

콘텍스트 API를 사용하면 Profile 컴포넌트가 중간에 개입하지 않고도 속성값 전달 가능



##### 콘텍스트 API를 사용한 코드

```react
const UserContext = React.createContext('unknown');

class App extends React.Component {
    render() {
        return (
        	<div>
            	<UserContext.Provider value="mike">
                	<div>상단 메뉴</div>
                    <Profile />
                    <div>하단 메뉴</div>
                </UserContext.Provider>
            </div>
        );
    }
}

function Profile() {
    return (
    	<div>
        	<Greeting />
            {/* ... */}
        </div>
    );
}

function Greeting() {
    return (
    	<UserContext.Consumer>
        	{username => <p>{`${username}님 안녕하세요`}</p>}
        </UserContext.Consumer>
    );
}
```

createContext 함수를 호출하면 콘텍스트 객체가 생성된다.

```react
React.createContext(defaultValue) => {Provider, Consumer}
```

상위 컴포넌트에서는 Provider 컴포넌트를 이용해서 데이터 전달

하위 컴포넌트에서는 Consumer 컴포넌트를 이용해서 데이터 사용

Consumer 컴포넌트는 데이터를 찾기 위해 상위로 올라가면서 가장 가까운 Provider 컴포넌트를 찾는다.

만약 최상위에 도달할 때까지 Provider 컴포넌트를  찾지 못한다면 기본값이 사용된다.



##### shouldComponentUpdate 메서드에서 거짓을 반환하는 예

```react
class App extends React.Component {
    state = {
        username: '',
    };
	onChangeName = e => {
        const username = e.target.value;
        this.setState({ username });
    };
	render() {
        const { username } = this.state;
        return (
        	<div>
            	<UserContext.Provider value={username}>
                	<Profile />
                </UserContext.Provider>
                <input type="text" value={username} onChange={this.onChangeName} />
            </div>
        );
    }
}

class Profile extends React.PureComponent {
    // ...
    render() {
        return (
        	<div>
            	<Greeting />
                {/* ... */}
            </div>
        );
    }
}

function Greeting() {
    return (
    	<UserContext.Consumer>
        	{username => <p>{`${username}님 안녕하세요`}</p>}
        </UserContext.Consumer>
    );
}
```

중간에 위치한 컴포넌트의 shouldComponentUpdate 메서드에서 거짓을 반환해도 Consumer 컴포넌트는 다시 렌더링된다.

username 상태값이 변경되면, App 컴포넌트는 다시 렌더링된다.

Profile 컴포넌트는 PureComponent로 만들어졌고, 속성값과 상태값이 없기 때문에 최초 렌더링 이후에는 다시 렌더링되지 않는다.

중간 컴포넌트의 렌더링 여부와 상관없이 Provider 컴포넌트로 새로운 데이터가 입력되면 Consumer 컴포넌트가 다시 렌더링되는 것이 보장된다.



### 3.4.2 콘텍스트 API 활용하기

여러 콘텍스트 객체를 중첩해서 사용하고, Consumer 컴포넌트를 사용하는 하위 컴포넌트에서 콘텍스트 데이터를 수정하며, 모든 생명 주기 메서드에서 콘텍스트 데이터에 접근하는 방법



#### 여러 콘텍스트를 중첩해서 사용하기

##### Provider, Consumer 컴포넌트를 중첩해서 사용한 예

```react
const UserContext = React.createContext('unknown');
const ThemeContext = React.createContext('dark');

class App extends React.Component {
    render() {
        return (
        	<div>
            	<ThemeContext.Provider value="light">
                	<UserContext.Provider value = "mike">
                    	<div>상단 메뉴</div>
                        <Profile />
                        <div>하단 메뉴</div>
                    </UserContext.Provider>
                </ThemeContext.Provider>
            </div>
        );
    }
}

function Profile() {
    return (
    	<div>
        	<Greeting />
            {/* ... */}
        </div>
    );
}

function Greeting() {
    return (
    	<ThemeContext.Consumer>
        	{theme => (
            	<UserContext.Consumer>
                	{username => (
                        <p
                            style={{ color: theme === 'dark' ? 'gray' : 'green' }}
                        >{`${username}님 안녕하세요`}</p>
                    )}
                </UserContext.Consumer>
            )}
        </ThemeContext.Consumer>
    );
}
```



#### 생명 주기 메서드에서 콘텍스트 데이터 사용하기

콘텍스트 데이터는 생명 주기 메서드에서도 사용할 수 있다.

클래스형 컴포넌트의 contextType 정적 멤버 변수에 콘텍스트 객체를 입력하면 클래스 내부에서 콘텍스트 데이터에 접근할 수 있다.



##### 생명 주기 메서드에서 콘텍스트 데이터 사용하기

```react
const ThemeContext = React.createContext('dark');

class MyComponent extends React.Component {
    componentDidMount() {
        const theme = this.context;
        // ...
    }
    // ...
}
MyComponent.contextType = ThemeContext;
```

클래스 내부에서 콘텍스트 데이터에 접근하기 위해 contextType 정적 멤버 변수에 콘텍스트 객체를 입력한다.

생명 주기 메서드에서 context 멤버 변수를 통해서 콘텍스트 데이터 사용가능



##### 생명 주기 메서드에서 여러 개의 콘텍스트 데이터 사용하기

```react
const UserContext = React.createContext('unknown');
const ThemeContext = React.createContext('dark');

class MyComponent extends React.Component {
    componentDidMount() {
        const { username, theme } = this.props;
        // ...
    }
    // ...
}

export default props => (
	<UserContext.Consumer>
    	{username => (
    		<ThemeContext.Consumer>
        		{theme => <MyComponent {...props} username={username} theme={theme} />}
        	</ThemeContext.Consumer>
    	)}
	</UserContext.Consumer>
);
```

Consumer 컴포넌트를 이용해서 콘텍스트 데이터를 MyComponent 컴포넌트의 속성값으로 넣는다.

username, theme 데이터는 MyComponent 컴포넌트 내부의 모든 메서드에서 사용 가능



#### 하위 컴포넌트에서 콘텍스트 데이터를 수정하기

##### 콘텍스트 데이터를 수정할 수 있는 함수 전달하기

```react
const UserContext = React.createContext({
    username: 'unknown',
    helloCount: 0,
    onHello: () => {},
});

class App extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            username: 'mike',
            helloCount: 0,
            onHello: this.onHello,
        };
    }
    onHello = () => {
        const { helloCount } = this.state;
        this.setState({ helloCount: helloCount + 1 });
    };
	render() {
        return (
        	<div>
            	<UserContext.Provider value={this.state}>
                	<div>상단 메뉴</div>
                    <Profile />
                    <div>하단 메뉴</div>
                </UserContext.Provider>
            </div>
        );
    }
}
```

helloCount를 증가시키는 함수를 콘텍스트 데이터에 포함시켰다.

App 컴포넌트의 전체 상태값을 콘텍스트 데이터를 관리하는 데 사용한다.

하위 컴포넌트에서 App 컴포넌트의 onHello 메서드를 호출할 수 있다.



##### 하위 컴포넌트에서 콘텍스트 데이터 수정하기

```react
function Greeting() {
    return (
    	<UserContext.Consumer>
        	{value => (
            	<React.Fragment>
                	<p>{`${value.username}님 안녕하세요`}</p>
                    <p>{`인사 횟수: ${value.helloCount}`}</p>
                    <button onClick={value.onHello}>인사하기</button>
                </React.Fragment>
            )}
        </UserContext.Consumer>
    );
}
```

App 컴포넌트로부터 전달된 onHello 함수를 버튼에 등록

Greeting 컴포넌트의 버튼을 클릭하면 콘텍스트 데이터가 수정된다.



### 3.4.3 콘텍스트 API 사용 시 주의할 점

콘텍스트 데이터가 변경되지 않은 상황에서 불필요한 렌더링이 발생하거나, Consumer 컴포넌트와 Provider 컴포넌트의 잘못된 위치 때문에 콘텍스트 데이터가 전달되지 않을 수 있다.



#### 불필요한 렌더링이 발생하는 경우

##### 불필요한 렌더링이 발생하는 예

```react
const UserContext = React.createContext({ name: 'unknown' });

class MyComponent extends React.Component {
    // ...
    onChangeName = e => {
        const name = e.target.value;
        this.setState({ name });
    };
	render() {
        const { name } = this.state;
        return (
        	<div>
            	<UserContext.Provider value={{ name }}>
                	{/* ... */}
                </UserContext.Provider>
            </div>
        );
    }
}
```

렌더링할 때마다 콘텍스트 데이터로 새로운 객체를 전달해서 불필요한 렌더링이 발생



##### 불필요한 렌더링이 발생하지 않는 코드

```react
class MyComponent extends React.Component {
    state = {
        userContextValue: {
            name: 'unknown',
        },
    };
	onChangeName = e => {
        const name = e.target.value;
        this.setState({ userContextValue: { name } });
    };
	// ...
	render() {
        const { userContextValue } = this.state;
        return (
        	<div>
            	<UserContext.Provider value={userContextValue}>
                	{/* ... */}
                </UserContext.Provider>
            </div>
        );
    }
}
```

콘텍스트 데이터 전체를 컴포넌트의 상태값으로 관리

name값이 변경되면 새로운 객체를 생성해서 상태값에 저장



#### Provider 컴포넌트를 찾지 못하는 경우

Consumer 컴포넌트와 Provider 컴포넌트를 적절한 위치에서 사용하지 않으면 콘텍스트 데이터가 전달되지 않는다.



##### Consumer 컴포넌트가 Provider 컴포넌트를 찾지 못하는 경우

```react
const UserContext = React.createContext('unknown');

class App extends React.Component {
    render() {
        return (
        	<div>
            	<UserContext.Provider value="mike">
                	{/* ... */}
                </UserContext.Provider>
                <Profile />
            </div>
        );
    }
}
```



## 3.5 ref 속성값으로 자식 요소에 접근하기

돔 요소에 직접 접근

돔 요소에 포커스를 주거나 돔 요소의 크기나 스크롤 위치를 알고 싶은 경우

ref 속성값을 이용하면 자식 요소(컴포넌트, 돔 요소)에 직접 접근할 수 있다.



### 3.5.1 ref 속성값 이해하기

##### 돔 요소에 접근하기 위해 ref 속성값을 사용한 예

```react
class TextInput extends React.Component {
    textRef = React.createRef();
	componentDidMount() {
        this.setTextFocus();
    }
	setTextFocus() {
        this.textRef.current.focus();
    }
	render() {
        return (
        	<div>
            	<input type="text" ref={this.textRef} />
                <button>저장</button>
            </div>
        );
    }
}
```

createRef 함수가 반환하는 ref 객체를 이용해서 자식 요소에 접근할 수 있다.

접근하고자 하는 자식 요소의 ref 속성값에 ref 객체 입력



##### 자식 컴포넌트에 접근하기 위해 ref 속성값을 사용한 예

```react
class Form extends React.Component {
    textInputRef = React.createRef();
	onClick = () => {
        this.textInputRef.current.setTextFocus();
    };
	render() {
        return (
        	<div>
            	<TextInput ref={this.textInputRef} />
                <button onClick={this.onClick}>텍스트로 이동</button>
            </div>
        );
    }
}
```

TextInput 컴포넌트에 ref 속성값 입력 => ref 속성값을 사용해 해당 컴포넌트의 메서드 호출 가능



### 3.5.2 ref 속성값 활용하기



#### 함수형 컴포넌트에서 ref 속성값 사용하기

ref 속성값은 클래스형 컴포넌트에만 사용할 수 있다.

함수형 컴포넌트 내부에서 생성되는 리액트 요소에 ref 속성값을 줄 수는 있다.

##### 함수형 컴포넌트에서 ref 속성값을 사용한 예

```react
function TextInput({ textRef }) {
    return (
    	<div>
            <input type="text" ref={textRef} />
            <button>저장</button>
        </div>
    );
}

class Form extends React.Component {
    textRef = React.createRef();
	componentDidMount() {
        this.setTextFocus();
    }
	setTextFocus = () => {
        this.textRef.current.focus();
    };
	render() {
        return (
        	<div>
            	<TextInput textRef={this.textRef} />
                <button onClick={this.setTextFocus}>텍스트로 이동</button>
            </div>
        );
    }
}
```

TextInput 컴포넌트의 내부 구조를 외부에서 알아야 하므로 좋은 방법은 아니다.



#### forwardRef 함수로 ref 속성값을 직접 처리하기



##### forwardRef 함수를 사용하는 코드

```react
const TextInput = React.forwardRef((props, ref) => (
    <div>
    	<input type="text" ref={ref} />
        <button>저장</button>
    </div>
));

class Form extends React.Component {
    // ...
    render() {
        return (
        	<div>
            	<TextInput ref={this.textRef} />
                <button onClick={this.setTextFocus}>텍스트로 이동</button>
            </div>
        );
    }
}
```

forwardRef 함수를 이용하면 부모 컴포넌트에서 넘어온 ref 속성값을 직접 처리할 수 있다.

textRef로 사용했던 이름을 리액트의 예약어인 ref로 사용할 수 있다.



#### ref 속성값으로 함수 사용하기

ref 속성값에 함수를 입력하면 createRef 함수 없이도 ref 속성값을 이용할 수 있다.



##### ref 속성값으로 함수를 사용한 예

```react
class Form extends React.Component {
    state = {
        showText: true,
    };
	textRef = null;
	onClickFocus = () => {
        if (this.textRef) {
            this.textRef.focus();
        }
    };
	onClickVisible = () => {
        const { showText } = this.state;
        this.setState({ showText: !showText });
    };
	render() {
        const { showText } = this.state;
        return (
        	<div>
            	{showText && <input type="text" ref={ref => (this.textRef = ref)} />}
                <button onClick={this.onClickFocus}>텍스트로 이동</button>
                <button onClick={this.onClickVisible}>텍스트 보이기/가리기</button>
            </div>
        );
    }
}
```

ref 속성값으로 함수를 입력하면, 매개변수로 돔 요소를 참조하는 변수가 넘어온다.

textRef 변수가 돔 요소를 직접 가리키기 때문에 current 속성은 필요 없다.

render 메서드가 호출될 때마다 this.textRef 변수에 두 번의 할당이 발생



##### ref 속성값으로 넣을 함수를 한 번만 생성하는 코드

```react
class Form extends React.Component {
    // ...
    setTextRef = ref => {
        if (ref === null) {
            console.log('돔 요소가 제거됨');
        }
        this.textRef = ref;
    };
	render() {
        const { showText } = this.state;
        return (
        	<div>
            	{showText && <input type="text" ref={this.setTextRef} />}
                <button onClick={this.onClickFocus}>텍스트로 이동</button>
                <button onClick={this.onClickVisible}>텍스트 보이기/가리기</button>
            </div>
        );
    }
}
```

render 메서드가 호출될 때마다 새로운 함수를 만들지 않으므로 input 요소가 생성되거나 사라질 때만 setTextRef 메서드가 호출된다.

onClickVisible 메서드를 호출하면 input 요소가 사라지고 setTextRef 함수는 null 인수와 함께 호출된다.

ref 속성값으로 함수를 사용하면 돔 요소의 생성과 소멸 시점을 알 수 있다.



### 3.5.3 ref 속성값 사용 시 주의할 점

컴포넌트가 마운트 된 이후라고 하더라도 ref 객체의 current 속성이 없을 수 있기 때문에 주의해야함

##### ref 객체의 current 속성이 없는 경우

```react
class Form extends React.Component {
    state = {
        showText: true,
    };
	textRef = React.createRef();
	onClickFocus = () => {
        this.textRef.current.focus();
    };
	onClickVisible = () => {
        const { showText } = this.state;
        this.setState({ showText: !showText });
    };
	render() {
        const { showText } = this.state;
        return (
        	<div>
            	{showText && <input type="text" ref={this.textRef} />}
                <button onClick={this.onClickFocus}>텍스트로 이동</button>
                <button onClick={this.onClickVisible}>텍스트 보이기/가리기</button>
            </div>
        );
    }
}
```

ref 속성값을 입력한 input 요소는 showText 상태값에 따라 존재하지 않을 수 있다. (showText의 초기값이 false일 때 `텍스트로 이동` 버튼을 클릭하면 오류 발생)

조건부 렌더링을 하는 경우 ref 객체를 사용할 때 주의

input 요소가 존재하지 않는 상태에서 onClickFocus 메서드가 호출되면 textRef 객체의 current 속성은 존재하지 않기 때문에 에러 발생 => current 속성을 검사하는 코드 필요



##### current 속성이 존재하는지 검사하기

```react
onClickFocus = () => {
    if (this.textRef.current) {
        this.textRef.current.focus();
    }
};
```

