# 2. JavaScript ES6+

## 2.1 변수를 정의하는 새로운 방법: const, let

### 2.1.1 var가 가진 문제

#### 함수 스코프

var의 첫 번째 문제는 정의된 변수가 함수 스코프를 가진다는 것이다.

스코프 : 변수가 사용될 수 있는 영역. 변수가 정의된 위치에 의해 결정된다.

함수 영역을 벗어난 영역에서 사용하면 에러 발생

```js
function example() {
    var i = 1;
}
console.log(i);  // 참조 에러
```



함수 안에서 var 키워드를 사용하지 않고 변수에 값을 할당하면 그 변수는 전역 변수가 된다.

```js
function example1() {
    i = 1;
}
function example2() {
    console.log(i);
}
example1();
example2();  // 1이 출력됨
```



var는 for 반복문에서 정의된 변수가 반복문이 끝난 이후에도 계속 남게 되는 문제가 있다.

```js
for (var i = 0; i < 10; i++) {
    console.log(i);
}
console.log(i);  // 10
```

while 문, switch 문, if 문 등도 마찬가지



#### 호이스팅

호이스팅 : var로 정의된 변수는 그 변수가 속한 스코프의 최상단으로 끌어올려진다.

##### 정의되지 않은 변수 사용하기

```js
console.log(myVar);  // 참조 에러
```

##### 변수가 정의된 시점보다 먼저 변수 사용하기

```js
console.log(myVar);  // undefined
var myVar = 1;
```

에러가 발생하지 않는다. 해당 변수가 호이스팅 되었기 때문이다.



##### 호이스팅 결과

```js
var myVar = undefined;
console.log(myVar);  // undefined
myVar = 1;
```

변수의 정의만 끌어올려지고 값은 원래 정의했던 위치에서 할당된다.



##### 변수가 정의된 시점보다 먼저 변수에 값을 할당하기

```js
console.log(myVar);  // undefined
myVar = 2;
console.log(myVar);  // 2
var myVar = 1;
```



#### var의 기타 문제들

var을 이용하면 한 번 정의된 변수를 재정의할 수 있다.

```js
var myVar = 1;
var myVar = 2;
```



var는 재할당 가능한 변수로밖에 만들 수 없다. 상수처럼 쓸 값도 무조건 재할당 가능한 변수로 만들어야 한다.



### 2.1.2 var의 문제를 해결하는 const, let

#### const, let은 블록 스코프다

블록 스코프에서는 블록을 벗어나면 변수를 사용할 수 없다.

```js
if (true) {
    const i = 0;
}
console.log(i);  // 참조 에러
```



블록 스코프에서 같은 이름을 갖는 변수의 사용 예

```js
let foo = 'bar1';
console.log(foo);  // bar1
if (true) {
    let foo = 'bar2';
    console.log(foo);  // bar2
}
console.log(foo);  // bar1
```



#### const, let에서의 호이스팅

const 또는 let으로 정의된 변수도 호이스팅된다. 하지만 const 또는 let으로 변수를 정의하기 전에 그 변수를 사용하려고 하면 참조 에러가 발생한다.

변수가 정의된 시점보다 먼저 변수를 사용할 수 없다.

```js
console.log(foo);  // 참조 에러
const foo = 1;
```



const에서 호이스팅의 역할을 설명하기 위한 예

```js
const foo = 1;
{
    console.log(foo);  // 참조 에러
    const foo = 2;
}
```

만약 변수가 호이스팅되지 않았다면 참조 에러는 발생하지 않고 값이 출력될 것이다.



var에서 호이스팅의 효과를 확인하는 코드

```js
var foo = 1;
(function() {
    console.log(foo);  // undefined
    var foo = 2;
})();
```



#### const는 변수를 재할당 불가능하게 만든다.

const로 정의된 변수는 재할당 불가능

let, var로 정의된 변수는 재할당 가능

```js
const bar = 'a';
bar = 'b';  // 에러 발생
var foo = 'a';
foo = 'b';  // 에러 없음
let value = 'a';
value = 'b';  // 에러 없음
```



#### const로 정의된 객체의 내부 속성값은 수정 가능하다.

```js
const bar = { prop1: 'a' };
bar.prop1 = 'b';
bar.prop2 = 123;
console.log(bar);  // { prop1: 'b', prop2: 123 }
const arr = [10, 20];
arr[0] = 100;
arr.push(300);
console.log(arr);  // [ 100, 20, 300 ]
```

객체의 내부 속성값도 수정 불가능하게 만들고 싶다면 immer, immutable.js 등의 외부 패키지를 활용하는 게 좋다. 이러한 외부 패키지는 객체를 수정하려고 할 때 기존 객체는 변경하지 않고 새로운 객체를 생성한다.

* 수정할 수 없도록 차단 => 자바스크립트 내장 함수 이용
  * Object.preventExtensions
  * Object.seal
  * Object.freeze



#### const로 정의된 변수에 재할당은 불가능하다.

```js
const bar = { prop1: 'a' };
bar = { prop2: 123 };  // 에러 발생
```



## 2.2 객체와 배열의 사용성 개선

단축 속성명과 계산된 속성명을 이용하면 객체와 배열을 생성하고 수정하는 코드를 쉽게 작성할 수 있다.

전개 연산자와 비구조와 할당을 이용해 객체와 배열의 속성값을 밖으로 꺼내는 방법이 쉬워졌다.



### 2.2.1 객체와 배열을 간편하게 생성하고 수정하기

#### 단축 속성명

* 객체 리터럴 코드를 간편하게 작성할 목적으로 만들어진 문법
* 간편하게 새로운 객체 생성 가능



##### 단축 속성명을 사용해서 객체를 생성하기

```js
const name = 'mike';
const obj = {
    age: 21,
    name,
    getName() {return this.name;},
};
```

새로 만들려는 객체의 속성값 일부가 이미 변수로 존재하면 간단하게 변수 이름만 적어주면 된다.

속성값이 함수이면 function 키워드 없이 함수명만 적어도 된다.



##### 단축 속성명을 사용하지 않은 코드와 사용한 코드를 비교하기

```js
function makePerson1(age, name) {
    return { age: age, name: name };
}
function makePerson2(age, name) {
    return { age, name };
}
```



##### 콘솔 로그 출력 시 단축 속성명 활용하기

```js
const name = 'mike';
const age = 21;
console.log('name = ', name, ', age = ', age);  // name = mike , age = 21
console.log({ name, age });  // { name: 'mike', age: 21 }
```



#### 계산된 속성명

* 객체의 속성명을 동적으로 결정하기 위해 나온 문법

##### 계산된 속성명을 사용하지 않은 코드와 사용한 코드 비교

```js
function makeObject1(key, value) {
    const obj = {};
    obj[key] = value;
    return obj;
}
function makeObject2(key, value) {
    return { [key]: value };
}
```



##### 계산된 속성명을 사용해서 컴포넌트 상탯값 변경하기

```js
class MyComponent extends React.Component {
    state = {
        count1: 0,
        count2: 0,
        count3: 0,
    };
	// ...
	onClick = index => {
        const key = `count${index}`;
        const value = this.state[key];
        this.setState({ [key]: value + 1 });
    };
}
```



### 2.2.2 객체와 배열의 속성값을 간편하게 가져오기

#### 전개 연산자

* 배열이나 객체의 모든 속성을 풀어놓을 때 사용
* 매개변수가 많은 함수를 호출할 때 유용

##### 전개 연산자를 이용해서 함수의 매개변수를 입력하기

```js
Math.max(1, 3, 7, 9);
const numbers = [1, 3, 7, 9];
Math.max(...numbers);
```

전개 연산자를 사용하면 동적으로 함수의 매개변수를 전달할 수 있다.



##### 전개 연산자를 이용해서 배열과 객체를 복사하기

```js
const arr1 = [1, 2, 3];
const obj1 = { age: 23, name: 'mike' };
const arr2 = [...arr1];
const obj2 = { ...obj1 };
arr2.push(4);
obj2.age = 80;
```

전개 연산자를 사용해서 새로운 객체와 배열 생성 => 속성을 추가하거나 변경해도 원래의 객체에 영향을 주지 않는다.



##### 배열에서 전개 연산자를 사용하면 순서가 유지된다.

```js
[1, ...[2, 3], 4];  // [1, 2, 3, 4]
new Date(...[2018, 10, 24]);  // 2018년 11월 24일
```



##### 전개 연산자를 이용해서 두 객체를 병합하기

```js
const obj1 = { age: 21, name: 'mike' };
const obj2 = { hobby: 'soccer' };
const obj3 = { ...obj1, ...obj2 };
console.log(obj3);  // { age: 21, name: 'mike', hobby: 'soccer' }
```



##### 객체 리터럴에서 중복된 속성명 사용 가능

```js
const obj1 = { x: 1, x: 2, y: 'a' };  // { x: 2, y: 'a' }
const obj2 = { ...obj1, y: 'b' };  // { x: 2, y: 'b' }
```

중복된 속성명 사용 시 최종 결과는 마지막 속성명의 값이 된다.



#### 배열 비구조화

* 배열의 여러 속성값을 변수로 쉽게 할당할 수 있는 문법

##### 배열 비구조화를 사용한 간단한 코드

```js
const arr = [1, 2];
const [a, b] = arr;
console.log(a);  // 1
console.log(b);  // 2
```

배열의 속성값이 왼쪽의 변수에 순서대로 들어간다.



##### 배열 비구조화로 이미 존재하는 변수에 값을 할당하기

```js
let a, b;
[a, b] = [1, 2];
```



##### 배열 비구조화에서의 기본값

```js
const arr = [1];
const [a = 10, b = 20] = arr;
console.log(a);  // 1
console.log(b);  // 20
```

두 번째 변수의 속성값은 undefined 이므로 기본값 20이 할당된다.



##### 배열 비구조화를 이용해서 두 변수의 값을 교환하기

```js
let a = 1;
let b = 2;
[a, b] = [b, a];
console.log(a);  // 2
console.log(b);  // 1
```



##### 쉼표를 이용해서 일부 속성값 건너뛰기

```js
const arr = [1, 2, 3];
const [a, , c] = arr;
console.log(a);  // 1
console.log(c);  // 3
```

두 번째 속성값은 건너뛰고 세 번째 속성값이 변수 c에 할당



##### 나머지 값을 별도의 배열로 만들기

```js
const arr = [1, 2, 3];
const [first, ...rest1] = arr;
console.log(rest1);  // [2, 3]
const [a, b, c, ...rest2] = arr;
console.log(rest2);  // []
```

나머지 모든 속성값이 새로운 배열로 만들어진다.



#### 객체 비구조화

* 객체의 여러 속성값을 변수로 쉽게 할당할 수 있는 문법

##### 객체 비구조화의 간단한 예

```js
const obj = { age: 21, name: 'mike' };
const { age, name } = obj;
console.log(age);  // 21
console.log(name);  // mike
```

객체 비구조화에서는 중괄호를 사용한다.

객체 비구조화에서 순서는 무의미하다.

기존 속성명을 그대로 사용해야 한다.



##### 객체 비구조화에서는 속성명이 중요하다

```js
const obj = { age: 21, name: 'mike' };
const { age, name } = obj;
const { name, age } = obj;
const { a, b } = obj;
```

존재하지 않는 속성명을 사용하면 undefined가 할당된다.



##### 객체 비구조화에서 별칭 사용하기

```js
const obj = { age: 21, name: 'mike' };
const { age: theAge, name } = obj;
console.log(theAge);  // 21
console.log(age);  // 참조 에러
```

속성명 age의 값을 theAge 변수에 할당한다. age 변수는 할당되지 않는다.



##### 객체 비구조화에서의 기본값

```js
const obj = { age: undefined, name: null, grade: 'A' };
const { age = 0, name = 'noName', grace = 'F' } = obj;
console.log(age);  // 0
console.log(name);  // null
console.log(grade);  // A
```

age는 undefined 이므로 기본값이 들어간다.

속성값이 null이면 기본값은 들어가지 않는다.



##### 기본값과 별칭 동시에 사용하기

```js
const obj = { age: undefined, name: 'mike' };
const { age: theAge = 0, name } = obj;
console.log(theAge);  // 0
```



##### 함수를 이용한 기본값

```js
function getDefaultAge() {
    console.log('hello');
    return 0;
}
const obj = { age: 21, grade: 'A' };
const { age = getDefaultAge(), grade } = obj;  // hello 출력되지 않음
console.log(age);  // 21
```

기본값이 사용될 때만 함수가 호출된다.



##### 객체 비구조화에서 나머지 속성들을 별도의 객체로 생성하기

```js
const obj = { age: 21, name: 'mike', grade: 'A' };
const { age, ...rest } = obj;
console.log(rest);  // { name: 'mike', grade: 'A' }
```



##### for 문에서 객체 비구조화를 활용한 예

```js
const people = [{ age: 21, name: 'mike' }, { age: 51, name: 'sara' }];
for (const { age, name } of people) {
    // ...
}
```



#### 비구조화 심화 학습

비구조화는 객체와 배열이 중첩되어 있을 때도 사용할 수 있다.

##### 중첩된 객체의 비구조화 사용 예

```js
const obj = { name: 'mike', mother: { name: 'sara' } };
const {
    name,
    mother: { name: motherName },
} = obj;
console.log(name);  // mike
console.log(motherName);  // sara
console.log(mother);  // 참조 에러
```



##### 기본값은 변수 단위가 아니라 패턴 단위로 적용된다

```js
const [{ prop: x } = { prop: 123 }] = [];
console.log(x);  // 123
const [{ prop: x } = { prop: 123 }] = [{}];
console.log(x);  // undefined
```

{ prop: x } 는 배열의 첫 번째 원소를 가리키고, { prop: 123 } 은 그 기본값을 정의한다.

첫 번째 원소가 존재하지 않는다. => 기본값 할당

배열의 첫 번째 원소가 존재 => 기본값이 할당되지 않는다.



##### 객체 비구조화에서 계산된 속성명 사용하기

```js
const index = 1;
const { [`key${index}`]: valueOfTheIndex } = { key1: 123 };
console.log(valueOfTheIndex);  // 123
```

객체 비구조화에서 계산된 속성명을 사용할 때에는 반드시 별칭을 입력해야 한다.



##### 별칭을 이용해서 다른 객체와 배열의 속성값 할당

```js
const obj = {};
const arr = [];
({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });
console.log(obj);  // {prop:123}
console.log(arr);  // [true]
```



## 2.3 강화된 함수의 기능

### 2.3.1 매개변수에 추가된 기능

#### 매개변수 기본값

##### 매개변수에 기본값 주기

```js
function printLog(a = 1) {
    console.log({ a });
}
printLog();  // { a: 1 }
```



##### 매개변수 기본값으로 함수 호출 사용하기

```js
function getDefault() {
    return 1;
}
function printLog(a = getDefault()) {
    console.log({ a });
}
printLog();  // { a: 1 }
```



##### 매개변수 기본값을 이용해서 필숫값을 표현하는 방법

```js
function required() {
    throw new Error('no parameter');
}
function pringLog(a = required()) {
    console.log({ a });
}
printLog(10);  // { a: 10 }
printLog();  // 에러 발생: no parameter
```



#### 나머지 매개변수

* 입력된 인수 중에서 정의된 매개변수 개수만큼을 제외한 나머지를 배열로 만들어 준다.
* 매개변수 개수가 가변적일 때 유용하다.



##### 나머지 매개변수를 사용한 코드

```js
function printLog(a, ...rest) {
    console.log({ a, rest });
}
printLog(1, 2, 3);  // { a: 1, rest: [2, 3] }
```

하나의 인자를 제외한 나머지를 rest 매개변수에 할당



##### arguments 키워드로 나머지 매개변수 따라 하기

```js
function printLog(a) {
    const rest = Array.from(arguments).splice(1);
    console.log({ a, rest });
}
printLog(1, 2, 3);  // { a: 1, rest: [2, 3] }
```

가독성이 좋지 않다.

arguments 를 배열로 변환하는 과정이 필요



#### 명명된 매개변수

* 객체 비구조화를 이용해서 구현할 수 있다.
* 함수 호출 시 매개변수의 이름과 값을 동시에 적을 수 있으므로 가독성이 높다.



##### 명명된 매개변수의 사용 여부에 따른 가독성 비교

```js
const numbers = [10, 20, 30, 40];
const result1 = getValues(numbers, 5, 25);
const result2 = getValues({ numbers, greaterThan: 5, lessThan: 25 });
```

명명된 매개변수를 이용하면 매개변수의 이름이 노출된다.



##### 명명된 매개변수의 사용 여부에 따른 선택적 매개변수 코드 비교

```js
const result1 = getValues(numbers, undefined, 25);
const result2 = getValues({ numbers, greaterThan: 5 });
const result3 = getValues({ numbers, lessThan: 25 });
```

선택적 매개변수 : 필숫값과는 반대되는 의미로, 있어도 되고 없어도 되는 매개변수이다.

명명된 매개변수 없이 선택적 매개변수 사용 => 필요 없는 매개변수 자리에 undefined를 넣으면 된다.

명명된 매개변수 사용시 필요한 인수만 넣어주면 된다.



### 2.3.2 화살표 함수

##### 화살표 함수의 사용 예

```js
const add = (a, b) => a + b;
console.log(add(1, 2));  // 3
const add5 = a => a + 5;
console.log(add5(1));  // 6
const addAndReturnObject = (a, b) => ({ result: a + b });
console.log(addAndReturnObject(1, 2).result);  // 3
```

객체 반환 시 소괄호로 감싸야 한다.



#### 화살표 함수의 코드가 여러 줄인 경우

전체를 중괄호로 묶고, 반환값에는 return 키워드 사용



##### 코드가 두 줄 이상인 화살표 함수

```js
const add = (a, b) => {
    if (a <= 0 || b <= 0) {
        throw new Error('must be positive number');
    }
    return a + b;
};
```



#### this와 arguments가 바인딩되지 않는 화살표 함수

화살표 함수가 일반 함수와 다른 점은 this와 arguments가 바인딩되지 않는다는 것이다. => arguments 필요 시 나머지 매개변수 사용



##### 화살표 함수에서 나머지 매개변수 사용하기

```js
const printLog = (...rest) => console.log(rest);
printLog(1, 2);  // [1, 2]
```



#### 일반 함수에서 this 바인딩 때문에 버그가 발생하는 경우

일반 함수에서 this는 호출 시점에 사용된 객체로 바인딩된다. => 객체에 정의된 일반 함수를 다른 변수에 할당해서 호출하면 버그가 발생할 수 있다.



##### this 바인딩 때문에 버그가 발생한 경우

```js
const obj = {
    value: 1,
    increase: function() {
        this.value++;
    },
};
obj.increase();
console.log(obj.value);  // 2
const increase = obj.increase;
increase();
console.log(obj.value);  // 2
```

객체 없이 호출되는 경우에는 전역 객체가 바인딩된다. => 브라우저 환경에서는 window 객체가 바인딩된다. => obj.value는 증가하지 않는다.

화살표 함수 안에서 사용된 this와 arguments는 자신을 감싸고 있는 가장 가까운 일반 함수의 것을 참조한다.



#### 생성자 함수 내부에서 정의된 화살표 함수의 this

생성자 함수 내부에서 정의된 화살표 함수의 this는 생성된 객체를 참조한다.

##### 생성자 함수 내부에서 화살표 함수 사용하기

```js
function Something() {
    this.value = 1;
    this.increase = () => this.value++;
}
const obj = new Something();
obj.increase();
console.log(obj.value);  // 2
const increase = obj.increase;
increase();
console.log(obj.value);  // 3
```

화살표 함수 increase의 this는 가장 가까운 일반 함수인 Something의 this를 참조한다.

new 키워드를 이용해서 생성자 함수를 호출하면 this는 생성되는 객체를 참조한다.

increase 함수의 this는 생성된 객체를 가리킨다.



#### setInterval 함수 사용 시 this 바인딩 문제

1초마다 obj.value를 증가시키는 코드



##### setInterval 함수에서 this 객체 사용 시 버그 발생

```js
function Something() {
    this.value = 1;
    setInterval(function increase() {
        this.value++;
    }, 1000);
}
const obj = new Something();
```

의도와 달리 obj.value가 증가하지 않는다.

increase 함수는 전역 환경에서 실행되기 때문에 this는 window 객체를 참조한다.



##### setInterval 함수에서 this 객체를 참조하기 위해 편법 사용

```js
function Something() {
    this.value = 1;
    var that = this;
    setInterval(function increase() {
        that.value++;
    }, 1000);
}
const obj = new Somethins();
```

increase 함수에서는 클로저(closure)를 이용해서 미리 저장해둔 that 변수를 통해 this 객체에 접근한다.



##### setInterval 함수에서 this 객체를 참조하기 위해 화살표 함수 사용하기

```js
function Something() {
    this.value = 1;
    setInterval(() => {
        this.value++;
    }, 1000);
}
const obj = new Something();
```

화살표 함수 사용 => this는 obj를 참조



